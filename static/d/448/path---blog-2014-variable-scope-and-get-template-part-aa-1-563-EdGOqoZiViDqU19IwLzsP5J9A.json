{"data":{"markdownRemark":{"html":"<p>In developing my company’s website, I’m attempting to be as modular as possible. Following this methodology, I’m making heavy use of <code class=\"language-text\">get_template_part</code> to abstract out the WordPress loop and make downstream changes to code easier to understand. Recently, however, I ran into an issue with attempting to use a global variable with <code class=\"language-text\">get_template_part</code>. The issue is pretty easy to understand, and is more a PHP deal than a WordPress one: variable scope. Variables are <em>mostly</em> global in PHP; variables defined can be referenced most anywhere else, including <code class=\"language-text\">required</code> or <code class=\"language-text\">included</code> files. However, user-defined functions have their own local function scope. Any variable used in that function is limited to that function only. Here’s an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"php\"><pre class=\"language-php\"><code class=\"language-php\">\t<span class=\"token php language-php\"><span class=\"token delimiter important\">&lt;?php</span>\n\t  <span class=\"token variable\">$a</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n\t  <span class=\"token keyword\">function</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t    <span class=\"token keyword\">echo</span> <span class=\"token variable\">$a</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// will not return anything</span>\n\t  <span class=\"token punctuation\">}</span>\n\t<span class=\"token delimiter important\">?></span></span></code></pre></div>\n<p> This threw me for a second; I’m used to global variables being accessible everywhere. But in PHP, functions have their own scope, and won’t have access to higher-level variables unless they are passed to the function in an argument, or declared with <code class=\"language-text\">global</code>. I didn’t want to declare a global variable within my template, and passing variables through <code class=\"language-text\">get_template_part</code> is exceeds the limitations of the WordPress function, so I had to find a different way to make sure my variables were accessible. To get around my problem, I opted to use the WP function <code class=\"language-text\">locate_template()</code>. locate<em>template is similar to `get</em>template<em>part<code class=\"language-text\">, except</code>locate</em>template<code class=\"language-text\">doesn&#39;t return the results of the arguments passed. It does exactly what it sounds like, which is locating templates. From there, I did a simple</code>include` to add the template. Here’s what the final result looked like:</p>\n<div class=\"gatsby-highlight\" data-language=\"php\"><pre class=\"language-php\"><code class=\"language-php\"><span class=\"token keyword\">include</span><span class=\"token punctuation\">(</span> <span class=\"token function\">locate_template</span><span class=\"token punctuation\">(</span> <span class=\"token double-quoted-string string\">\"template-part.php\"</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p> It honestly feels a little hack-y to me, but it gets the job done. No more worries about function-level scoping, all the benefits of <code class=\"language-text\">get_template_part</code>, and a modular website back-end. For more information about how scoping is handled in PHP, check out the documentation here: <a href=\"http://www.php.net/manual/en/language.variables.scope.php\">http://www.php.net/manual/en/language.variables.scope.php</a></p>","frontmatter":{"title":"Variable scope and get_template_part","date":null}}},"pageContext":{"slug":"variable-scope-and-get_template_part","type":"blog"}}