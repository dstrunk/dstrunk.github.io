{"data":{"markdownRemark":{"html":"<p>Part of my day job involves designing and sending out email campaigns for various customers. On the whole it’s a pretty painless job, with one sticking point: getting a properly sanitized email list of subscribers is hard. Depending on the client supplying the spreadsheet, any number of things could go wrong:</p>\n<ul>\n<li>duplicate entries</li>\n<li>empty lines</li>\n<li>malformed email addresses</li>\n<li>ALL CAPS ENTRIES / lowercased entries</li>\n</ul>\n<p>In addition to these problems, the data usually doesn’t come in a format that I need to upload to our campaign manager (Yes I know a CRM would mitigate all of these issues, but that’s beside the point). Being the <del>lazy</del> resourceful Ruby developer I am, I created a simple script to parse a .csv list and output the information I’m looking for. I’ll post it first, then go through and explain what the lines do.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">require &#39;csv&#39;\n\nunless ARGV.length == 2\n  puts &quot;Sorry, incorrect number of arguments.&quot;\n  puts &quot;Usage: ruby parse.rb InputFile.csv OutputFile.csv\\n&quot;\n  exit\nend\n\nET_HEADERS = %w(Email\\ Address Subscriber\\ Key First\\ Name LastName).freeze\n\nnew_list = []\n\nold_list = CSV.read(ARGV[0], &quot;r:windows-1251:utf-8&quot;, headers: true, skip_blanks: true).reject { |row| row.to_hash.values.all?(&amp;:nil?) }\n\nold_list.each do |row|\n  new_list &lt;&lt; row unless row[&quot;confirmed&quot;] == &quot;yes&quot;\nend\n\nCSV.open(ARGV[1], &#39;wb&#39;) do |csv|\n  csv &lt;&lt; ET_HEADERS\n  new_list.each do |row|\n    csv &lt;&lt; [row[&quot;email&quot;], row[&quot;email&quot;], row[&quot;fname&quot;], row[&quot;lname&quot;]]\n  end\nend</code></pre></div>\n<p>So how does this script work, exactly? It’s pretty easy: open terminal and run <code class=\"language-text\">ruby parse.rb inputfile.csv outputfile.csv</code> (all names are self-explanitory, hopefully). Now to break down the blocks.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">require &#39;csv&#39;</code></pre></div>\n<p>This requires the <code class=\"language-text\">csv</code> library that comes standard with Ruby. Don’t worry; it’s not a gem, you don’t have to download anything. Just include it at the top of your file.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">unless ARGV.length == 2\n  puts &quot;Sorry, incorrect number of arguments.&quot;\n  puts &quot;Usage: ruby parse.rb InputFile.csv OutputFile.csv\\n&quot;\n  exit\nend</code></pre></div>\n<p>Here’s some simple error handling. This script expects two arguments after invoking it in the command line: an input file and an output file. If the script detects anything more or less, it will exit with a nice but stern explanation why.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ET_HEADERS = %w(Email\\ Address Subscriber\\ Key First\\ Name LastName).freeze\nnew_list = []</code></pre></div>\n<p>Here I setup a constant and a variable I’ll be using down the road. <code class=\"language-text\">ET_HEADERS</code> is a constant that holds the headers the campaign manager needs to be properly uploaded. <code class=\"language-text\">new_list</code> is a variable instantiated with a new array; we’ll be injecting the parsed contents of our old list into this array.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">old_list = CSV.read(ARGV[0], &quot;r:windows-1251:utf-8&quot;, headers: true, skip_blanks: true).reject { |row| row.to_hash.values.all?(&amp;:nil?) }</code></pre></div>\n<p>This is probably the most complex part of the script, but it’s not so bad. We’re creating a new variable called <code class=\"language-text\">old_list</code>. In <code class=\"language-text\">old_list</code>, we use the CSV library to open up <code class=\"language-text\">ARGV[0]</code>, the first argument in our command line. The gnarly <code class=\"language-text\">r:windows-1251:utf-8</code> is telling Ruby to transcode whatever file format the csv file is into something it can work with; <code class=\"language-text\">headers: true</code> tells the file to include headers; and <code class=\"language-text\">skip_blanks: true</code> tells the CSV reader to (surprise!) skip blanks. the <code class=\"language-text\">reject</code> block tells the CSV reader that, for each row, if all values are nil, remove them completely.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">old_list.each do |row|\n  new_list &lt;&lt; row unless row[&quot;confirmed&quot;] == &quot;yes&quot;\nend</code></pre></div>\n<p>Once a list has been screened for blanks, we’ll throw them into the new array (<code class=\"language-text\">new_list</code> variable set up at the beginning). Here’s where I’ll add my edge-case conditionals. Things like “If a user has confirmed or RSVPed,” or “If a user hasn’t responded within a week.”</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CSV.open(ARGV[1], &#39;wb&#39;) do |csv|\n  csv &lt;&lt; ET_HEADERS\n  new_list.each do |row|\n    csv &lt;&lt; [row[&quot;email&quot;], row[&quot;email&quot;], row[&quot;fname&quot;], row[&quot;lname&quot;]]\n  end\nend</code></pre></div>\n<p>Now that we’ve got our “sanitized” list, it’s time to open a new CSV file. We open a new CSV file as specified in <code class=\"language-text\">ARGV[1]</code>, and begin building our new file. First, we add the <code class=\"language-text\">ET_HEADERS</code> to the first row. Then, for each array entry in <code class=\"language-text\">new_list</code>, we append the necessary columns to our new document.</p>\n<h2>Future plans</h2>\n<p>The script is pretty basic at this point, but it does its job well. One problem I have with the script is it requires knowledge of the input script, and requires modifying appended columns based on the input CSV file. In the future it would be nice to build out a prompt that reads the headers of the input CSV, and allow the user (me) to select which rows I’m looking for (as well as potentially any conditionals to the input list to look for).</p>\n<p>As it stands, however, it works great. List digestion has gone from a 15-20 minute job down to a 1-2 minute job, and with the amount of emails that come onto my desk daily, that’s easily a 3-4 hours a week saved on processing lists. Not bad for 17 lines of code!</p>","frontmatter":{"title":"Automating CSV parsing with Ruby","date":null}}},"pageContext":{"slug":"automating-csv-parsing-with-ruby","type":"blog","jekyllDate":"2014-11-18"}}