{"data":{"markdownRemark":{"html":"<p>With the target date of <a href=\"http://ecma-international.org/memento/TC39-M.htm\" title=\"TC39 - ECMAScript\">December 2013</a> looming ever closer, I thought it would be good to write up a series of posts concerning the upcoming ECMAScript 6. This post will talk about the <code class=\"language-text\">let</code> keyword. It’s a pretty simple concept, but I think it will clear up a lot of headaches with development.</p>\n<h3><code class=\"language-text\">let</code> vs <code class=\"language-text\">var</code></h3>\n<p>In JavaScript, the <code class=\"language-text\">var</code> keyword declares a variable. The scope of the variable defined using the <code class=\"language-text\">var</code> keyword is the enclosing function, or, if the variable is defined outside a function, the global scope (for front end development, usually the <code class=\"language-text\">window</code> object). The way JavaScript handles scoping can be confusing at times; especially because JavaScript has function-level scope. First, an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var x = 1;\nconsole.log( x ); // 1\n\nif ( true ) {\n\tvar x = 2;\n\tconsole.log( x ); // 2\n}\n\nconsole.log( x ); // 2</code></pre></div>\n<p>People coming from a C family would be confused at this output, expecting x to output 1. That’s because the C family (as well as many other languages) enjoys <strong>block-level scope</strong>. That means a variable declared within any block, such as an <code class=\"language-text\">if</code> statement, won’t affect the global scope. In current JavaScript, however, variables enjoy <strong>function-level scope</strong>. That means blocks (such as the one above) won’t create a new scope—only functions do. A variable declared within a block statement gets hoisted up to the nearest function block, and if one doesn’t exist, the global object. So our code above might as well have read like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var x = 1;\nconsole.log( x ); // 1\n\nvar x = 2;\nif ( true ) {\n\tconsole.log( x ); // 2\n}\n\nconsole.log( x ); // 2</code></pre></div>\n<p><code class=\"language-text\">let</code>, on the other hand, allows you to declare variables limited in scope to the block, statement, or expression where it’s used. Let’s try the example again, subbing in <code class=\"language-text\">let</code> for the x declared within the <code class=\"language-text\">if</code> statement:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var x = 1;\nconsole.log( x ); // 1\n\nif ( true ) {\n\tlet x = 2;\n\tconsole.log( x ); // 2\n}\n\nconsole.log( x ); // 1</code></pre></div>\n<p>Much better! In my opinion, this is something that should have been included in JavaScript from the get-go. That’s not to say that it’s without its own caveats. You need to be mindful of redeclaration within things like <code class=\"language-text\">switch</code> statements, for example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">switch ( x ) {\n\tcase 0:\n\t\tlet foo;\n\t\tbreak;\n\tcase 1:\n\t\tlet foo; // TypeError for redeclaration\n\t\tbreak;\n}</code></pre></div>\n<p>Barring this, I believe the <code class=\"language-text\">let</code> keyword will clear up some confusion that might come up with a variable declared within a <code class=\"language-text\">for</code> loop or <code class=\"language-text\">if</code> statement.</p>\n<p><small>*Tests used in this post will currently only work with the most recent version of Mozilla Firefox.</small></p>","frontmatter":{"title":"ECMAScript 6 features: let","date":null}}},"pageContext":{"slug":"ecmascript-6-features-let","type":"blog"}}