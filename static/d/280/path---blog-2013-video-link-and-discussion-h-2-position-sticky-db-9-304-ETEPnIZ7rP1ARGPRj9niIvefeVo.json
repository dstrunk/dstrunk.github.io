{"data":{"markdownRemark":{"html":"<p><strong>via <a href=\"https://air.mozilla.org/intern-presentation-ford/\" title=\"Air Mozilla - h2 position sticky\">https://air.mozilla.org/intern-presentation-ford/</a> -</strong> Here’s an exciting pseudo-proposition to CSS3: <code class=\"language-text\">position: sticky</code>. “Sticky” elements are similar to fixed positioning, in that they stay “fixed” to a viewport-relative position. The difference with sticky elements though (and one that I’m very excited about) is that sticky elements maintain their relativity to their parent containers. A trend that’s been going around a while in web design lately has been having elements remain sticky only for certain parts of a page. To paraphrase somebody that can explain this behaviour better than I:</p>\n<blockquote>\n<p>Many web sites have elements that alternate between being in-flow and having <code class=\"language-text\">position: fixed</code>, depending on the user’s scroll position. This is often done for elements in a sidebar that the page author wants to be always visible as the user scrolls, but which slot into a space on the page when scrolled to the top. Good examples are <a href=\"https://news.google.com/\">news.google.com</a> (the “Top Stories” sidebar) and yelp.com (<a href=\"http://www.yelp.com/search?find_desc=restaurants&#x26;find_loc=San+Francisco%2C+CA&#x26;ns=1\">search results map</a>). <cite>Edward O’Connor</cite></p>\n</blockquote>\n<h2>The old way</h2>\n<p>The old approach to this behaviour was adding a JavaScript event listener to a scroll event, and changing the CSS of the element in question when the window reached a certain point. The problem with this method is twofold. First up: fixed and relative positioning have different behaviors (obviously). Relatively positioned elements honor parent containers, while fixed positioned elements are positioned according to the viewport and are effectively removed from the regular DOM flow, CSS-wise. What I mean to say is things like margins on fixed elements don’t effect other elements on the page; if you were to think of a document in terms of layers, a fixed positioned element would always be at the top. So, the problem is: you need to be careful if you’re using margins or floats to position the relatively positioned elements—when they change to fixed elements, they might cause layout reflow issues. The second problem with the old approach is the scroll handler in general. <a href=\"http://ejohn.org/blog/learning-from-twitter/\" title=\"John Resig - Learning from Twitter\">Here’s</a> a good article from John Resig that mentions scroll events and an old issue with Twitter’s site (2011). In practice, it’s usually a bad idea to attach event listeners to scroll handlers, since (depending on browsers) a scroll event can happen <strong>a lot</strong>.</p>\n<h2>Consensus: sticky is good</h2>\n<p>As mentioned before, sticky positioned elements stay “fixed” to the page, but maintain their relativity to their parent containers. That means that the old way of keeping an element “stuck” to the viewport can now be achieved 100% with CSS. No event listeners to slow down performance of the page, no layout reflow issues, just good, clean CSS. Unfortunately, as far as support goes, <code class=\"language-text\">position: sticky</code> doesn’t get much. As of this writing, there are no official specs concerning <code class=\"language-text\">position: sticky</code>, and browser support is pretty experimental. While I don’t recommend using position: sticky in your production code, I do think that this feature is welcome and fits CSS’s spec. I for one hope to see it implemented soon; what about you? Thoughts?</p>","frontmatter":{"title":"Video link and discussion: h2 position sticky","date":null}}},"pageContext":{"slug":"video-link-and-discussion-h2-position-sticky","type":"blog","jekyllDate":"2013-09-12"}}