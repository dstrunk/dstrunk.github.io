{"data":{"markdownRemark":{"html":"<p>The prevailing mantra with git, or any version control system for that matter, is “commit early, commit often.” For the last year, I’ve been doing so, which is a Good Thing. And if I were to continue working as a team of one developer, that might be fine. But if you’re looking to commit to an open source project like I am, you’ll probably want to learn how to clean up your git commits so entries don’t include “forgot to add file” or “stupid mistake”. That’s where squashing comes in.</p>\n<p>Squashing commits, in simple terms, is pretty much what it sounds like—squashing together multiple commits into a single commit. That allows you to commit early and often (with mistakes, as things sometimes go), while still enjoying a clean, respectible git repository when you finally push your changes to master. How do you do it? Glad you asked.</p>\n<p>Let’s say you’ve made a few small commits, and want to make a larger commit out of them. You can use interactive rebasing to take care of this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git rebase -i HEAD~4\n\npick 000001a Add files\npick 000002b Oops! Forgot to add files\npick 000003c Added external library to make changes easier\npick 000004d Large code changes that actually matter\n\n# Commands:\n# p, pick = use commit\n# e, edit = use commit, but stop for ammending\n# s, squash = use commit, but meld into previous commit</code></pre></div>\n<p>This command will tells git that you want to rebase the last four commits from where <code class=\"language-text\">HEAD</code> is to <code class=\"language-text\">HEAD~4</code>. From there you’re taken to an editor with text in it, and an explanation of what can be done. Change your file to look something like the below:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pick 000001a Add files\nsqaush 000002b Oops! Forgot to add files\nsquash 000003c Added external library to make changes easier\nsquash 000004d Large code changes that are worthy of a longer commit.</code></pre></div>\n<p>This essentially tells git to combine the all of the commits with the first in the list. Once saved, another editor pops up:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># This is a combination of 4 commits\n# The first commit&#39;s message is:\nAdd files\n\n# This is the 2nd commit message:\nOops! Forgot to add files\n...</code></pre></div>\n<p>This file shows all of the previous commits, and allows you to modify the message of the squashed commits based on the rest of the commits involved. Edit the message as necessary, and <a href=\"http://robots.thoughtbot.com/5-useful-tips-for-a-better-commit-message\">be explicit</a>. Save the file and quit, and your commits will be successfully squashed!</p>\n<p>If you run into conflicts during the rebase, they’re usually pretty painless. Git is solid at leading you through: display the conflicting files, allow you to edit the files, <code class=\"language-text\">git add</code>, then <code class=\"language-text\">git rebase --continue</code> to resume the squashing process.</p>\n<p>If you take a look at your <code class=\"language-text\">git log</code>, you’ll see the history reflects your squash. Pushing to master will display to users only the history you want them to see—the meat of your commits, and not your mistakes.</p>","frontmatter":{"title":"Squashing git commits with rebase","date":null}}},"pageContext":{"slug":"squashing-git-commits-with-rebase","type":"blog"}}